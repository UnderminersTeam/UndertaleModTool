/*
  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

using System;
using System.Collections.Generic;
using Underanalyzer.Compiler.Errors;
using Underanalyzer.Compiler.Lexer;
using Underanalyzer.Compiler.Parser;
using Underanalyzer.Compiler.Nodes;
using Underanalyzer.Compiler.Bytecode;

namespace Underanalyzer.Compiler;

/// <summary>
/// Kind of script being compiled.
/// </summary>
public enum CompileScriptKind
{
    Script,
    GlobalScript,
    RoomCreationCode,
    ObjectEvent,
    Timeline
}

/// <summary>
/// A compilation context belonging to a single code entry in a game.
/// </summary>
public sealed class CompileContext(string code, CompileScriptKind scriptKind, string? globalScriptName, IGameContext gameContext)
{
    /// <summary>
    /// Source GML code being compiled.
    /// </summary>
    public string Code { get; } = code;

    /// <summary>
    /// Kind of script being compiled.
    /// </summary>
    public CompileScriptKind ScriptKind { get; } = scriptKind;

    /// <summary>
    /// Global script name for the code being compiled, or <see langword="null"/> if no such name is applicable.
    /// </summary>
    public string? GlobalScriptName { get; } = globalScriptName;

    /// <summary>
    /// The game context this compile context belongs to.
    /// </summary>
    public IGameContext GameContext { get; } = gameContext;

    /// <summary>
    /// Macros declared by this code, or otherwise externally added.
    /// </summary>
    public Dictionary<string, Macro> Macros { get; } = new(4);

    /// <summary>
    /// Enums declared by this code, or otherwise externally added.
    /// </summary>
    public Dictionary<string, GMEnum> Enums { get; } = new(4);

    /// <summary>
    /// List of errors generated by this compile context.
    /// </summary>
    public IReadOnlyList<ICompileError> Errors => _errors;

    /// <summary>
    /// Whether any errors have occurred on this context.
    /// </summary>
    public bool HasErrors => _errors.Count > 0;

    /// <summary>
    /// List of instructions, set after produced by code generation.
    /// </summary>
    public IReadOnlyList<IGMInstruction>? OutputInstructions { get; private set; } = null;

    /// <summary>
    /// Root function scope, set after code generation.
    /// </summary>
    public FunctionScope? OutputRootScope { get; private set; } = null;

    /// <summary>
    /// Collection of global function names, only available between parsing and code generation.
    /// </summary>
    /// <remarks>
    /// To retrieve global function names after code generation, use <see cref="OutputFunctionEntries"/> instead.
    /// </remarks>
    public IReadOnlyCollection<string>? OutputGlobalFunctionNames => _parseGlobalFunctions;

    /// <summary>
    /// List of sub-function entries, set after produced by code generation.
    /// </summary>
    public IReadOnlyList<FunctionEntry>? OutputFunctionEntries { get; private set; } = null;

    /// <summary>
    /// Length of code (in bytes), set after produced by code generation.
    /// </summary>
    public int OutputLength { get; private set; } = 0;

    // List of errors
    private readonly List<ICompileError> _errors = new(4);

    // State tracking
    private bool _startedParse = false;
    private IASTNode? _parseRootNode = null;
    private FunctionScope? _parseRootScope = null;
    private HashSet<string>? _parseGlobalFunctions = null;
    private bool _startedCompile = false;
    private InstructionPatches _compilePatches;
    private bool _startedLink = false;

    /// <summary>
    /// Parses the GML code with the given game context.
    /// </summary>
    public void Parse()
    {
        // Ensure parse only occurs once
        if (_startedParse)
        {
            throw new InvalidOperationException("Code parse already started");
        }
        _startedParse = true;

        // Tokenize/lex code
        LexContext rootLexContext = new(this, Code);
        rootLexContext.Tokenize();

        // Exit if any errors occurred
        if (HasErrors)
        {
            return;
        }

        // Post-process tokens
        rootLexContext.PostProcessTokens();

        // Exit if any errors occurred
        if (HasErrors)
        {
            return;
        }

        // Parse tokens into tree
        ParseContext parseContext = new(this, rootLexContext.Tokens);
        parseContext.Parse();

        // Exit if any errors occurred
        if (HasErrors)
        {
            return;
        }

        // Post-process parse tree
        parseContext.PostProcessTree();

        // Exit if any errors occurred
        if (HasErrors)
        {
            return;
        }

        // Successful parse! Store results.
        _parseRootNode = parseContext.Root;
        _parseRootScope = parseContext.RootScope;
        _parseGlobalFunctions = parseContext.ParseGlobalFunctions;
    }

    /// <summary>
    /// Compiles the GML code with the given game context. Will re-use earlier parse results if available.
    /// </summary>
    public void Compile(int initialPosition = 0)
    {
        // Ensure compile only occurs once
        if (_startedCompile)
        {
            throw new InvalidOperationException("Code compile already started");
        }
        _startedCompile = true;

        // Parse code if not already done
        if (!_startedParse)
        {
            Parse();
        }
        if (_parseRootNode is null || _parseRootScope is null)
        {
            return;
        }

        // Generate bytecode
        BytecodeContext bytecodeContext = new(this, _parseRootNode, _parseRootScope, _parseGlobalFunctions);
        bytecodeContext.GenerateCode(initialPosition);

        // Exit if any errors occurred
        if (HasErrors)
        {
            return;
        }

        // Successful code generation! Store results.
        OutputInstructions = bytecodeContext.Instructions;
        OutputFunctionEntries = bytecodeContext.FunctionEntries;
        OutputRootScope = _parseRootScope;
        OutputLength = bytecodeContext.Position;
        _compilePatches = bytecodeContext.Patches;

        // Remove references that we no longer need
        _parseRootNode = null;
        _parseRootScope = null;
        _parseGlobalFunctions = null;
    }

    /// <summary>
    /// Links resulting bytecode to data, if a successful compile was completed.
    /// </summary>
    /// <remarks>
    /// Before linking, <see cref="OutputFunctionEntries"/> should be iterated over. Each entry should have its function resolved,
    /// and struct instantiations should have their struct names resolved.
    /// If the code is a global script, all locally-declared global function names should be registered.
    /// </remarks>
    public void Link()
    {
        // Ensure link only occurs once
        if (_startedLink)
        {
            throw new InvalidOperationException("Code link already started");
        }
        _startedLink = true;

        // Ensure compile successfully finished
        if (!_startedCompile || OutputInstructions is null)
        {
            throw new InvalidOperationException("Code compile was not completed; linking may not occur");
        }

        // Post-process bytecode
        BytecodeContext.PatchInstructions(this, _compilePatches);

        // Remove references that we no longer need
        _compilePatches = default;
    }

    /// <summary>
    /// Pushes a lexer error to the list of errors generated for this compile context.
    /// </summary>
    internal void PushError(string message, LexContext lexContext, int textPosition)
    {
        _errors.Add(new LexerError(message, lexContext, textPosition));
    }

    /// <summary>
    /// Pushes a parser error to the list of errors generated for this compile context.
    /// </summary>
    internal void PushError(string message, IToken? nearbyToken = null)
    {
        _errors.Add(new ParserError(message, nearbyToken));
    }
}
